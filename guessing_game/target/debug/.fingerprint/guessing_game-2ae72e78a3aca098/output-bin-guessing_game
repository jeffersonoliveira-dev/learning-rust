{"$message_type":"diagnostic","message":"unreachable pattern","code":{"code":"unreachable_patterns","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":601,"byte_end":615,"line_start":28,"line_end":28,"column_start":9,"column_end":23,"is_primary":true,"text":[{"text":"        Ordering::Less => println!(\"Too big\"),","highlight_start":9,"highlight_end":23}],"label":"no value can reach this","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":551,"byte_end":565,"line_start":27,"line_end":27,"column_start":9,"column_end":23,"is_primary":false,"text":[{"text":"        Ordering::Less => println!(\"Too small!\"),","highlight_start":9,"highlight_end":23}],"label":"matches all the relevant values","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unreachable_patterns)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unreachable pattern\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:28:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m27\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Ordering::Less => println!(\"Too small!\"),\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m--------------\u001b[0m \u001b[1m\u001b[94mmatches all the relevant values\u001b[0m\n\u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Ordering::Less => println!(\"Too big\"),\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[33mno value can reach this\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unreachable_patterns)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"unreachable pattern","code":{"code":"unreachable_patterns","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":648,"byte_end":662,"line_start":29,"line_end":29,"column_start":9,"column_end":23,"is_primary":true,"text":[{"text":"        Ordering::Less => println!(\"You Win!\"),","highlight_start":9,"highlight_end":23}],"label":"no value can reach this","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":551,"byte_end":565,"line_start":27,"line_end":27,"column_start":9,"column_end":23,"is_primary":false,"text":[{"text":"        Ordering::Less => println!(\"Too small!\"),","highlight_start":9,"highlight_end":23}],"label":"matches all the relevant values","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unreachable pattern\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:29:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m27\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Ordering::Less => println!(\"Too small!\"),\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m--------------\u001b[0m \u001b[1m\u001b[94mmatches all the relevant values\u001b[0m\n\u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Ordering::Less => println!(\"Too big\"),\n\u001b[1m\u001b[94m29\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Ordering::Less => println!(\"You Win!\"),\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[33mno value can reach this\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"non-exhaustive patterns: `std::cmp::Ordering::Equal` and `std::cmp::Ordering::Greater` not covered","code":{"code":"E0004","explanation":"This error indicates that the compiler cannot guarantee a matching pattern for\none or more possible inputs to a match expression. Guaranteed matches are\nrequired in order to assign values to match expressions, or alternatively,\ndetermine the flow of execution.\n\nErroneous code example:\n\n```compile_fail,E0004\nenum Terminator {\n    HastaLaVistaBaby,\n    TalkToMyHand,\n}\n\nlet x = Terminator::HastaLaVistaBaby;\n\nmatch x { // error: non-exhaustive patterns: `HastaLaVistaBaby` not covered\n    Terminator::TalkToMyHand => {}\n}\n```\n\nIf you encounter this error you must alter your patterns so that every possible\nvalue of the input type is matched. For types with a small number of variants\n(like enums) you should probably cover all cases explicitly. Alternatively, the\nunderscore `_` wildcard pattern can be added after all other patterns to match\n\"anything else\". Example:\n\n```\nenum Terminator {\n    HastaLaVistaBaby,\n    TalkToMyHand,\n}\n\nlet x = Terminator::HastaLaVistaBaby;\n\nmatch x {\n    Terminator::TalkToMyHand => {}\n    Terminator::HastaLaVistaBaby => {}\n}\n\n// or:\n\nmatch x {\n    Terminator::TalkToMyHand => {}\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":515,"byte_end":540,"line_start":26,"line_end":26,"column_start":11,"column_end":36,"is_primary":true,"text":[{"text":"    match guess.cmp(&secret_number) {","highlight_start":11,"highlight_end":36}],"label":"patterns `std::cmp::Ordering::Equal` and `std::cmp::Ordering::Greater` not covered","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`std::cmp::Ordering` defined here","code":null,"level":"note","spans":[{"file_name":"/rustc/254b59607d4417e9dffbc307138ae5c86280fe4c/library/core/src/cmp.rs","byte_start":14269,"byte_end":14286,"line_start":392,"line_end":392,"column_start":1,"column_end":18,"is_primary":true,"text":[],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/rustc/254b59607d4417e9dffbc307138ae5c86280fe4c/library/core/src/cmp.rs","byte_start":14537,"byte_end":14542,"line_start":398,"line_end":398,"column_start":5,"column_end":10,"is_primary":false,"text":[],"label":"not covered","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/rustc/254b59607d4417e9dffbc307138ae5c86280fe4c/library/core/src/cmp.rs","byte_start":14670,"byte_end":14677,"line_start":401,"line_end":401,"column_start":5,"column_end":12,"is_primary":false,"text":[],"label":"not covered","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the matched value is of type `std::cmp::Ordering`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":686,"byte_end":686,"line_start":29,"line_end":29,"column_start":47,"column_end":47,"is_primary":true,"text":[{"text":"        Ordering::Less => println!(\"You Win!\"),","highlight_start":47,"highlight_end":47}],"label":null,"suggested_replacement":",\n        std::cmp::Ordering::Equal | std::cmp::Ordering::Greater => todo!()","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0004]\u001b[0m\u001b[1m: non-exhaustive patterns: `std::cmp::Ordering::Equal` and `std::cmp::Ordering::Greater` not covered\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:26:11\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m26\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     match guess.cmp(&secret_number) {\n   \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mpatterns `std::cmp::Ordering::Equal` and `std::cmp::Ordering::Greater` not covered\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: `std::cmp::Ordering` defined here\n  \u001b[1m\u001b[94m--> \u001b[0m/rustc/254b59607d4417e9dffbc307138ae5c86280fe4c/library/core/src/cmp.rs:392:1\n  \u001b[1m\u001b[94m::: \u001b[0m/rustc/254b59607d4417e9dffbc307138ae5c86280fe4c/library/core/src/cmp.rs:398:5\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: \u001b[1m\u001b[94mnot covered\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/rustc/254b59607d4417e9dffbc307138ae5c86280fe4c/library/core/src/cmp.rs:401:5\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: \u001b[1m\u001b[94mnot covered\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the matched value is of type `std::cmp::Ordering`\n\u001b[1m\u001b[96mhelp\u001b[0m: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m29\u001b[0m \u001b[92m~ \u001b[0m        Ordering::Less => println!(\"You Win!\")\u001b[92m,\u001b[0m\n\u001b[1m\u001b[94m30\u001b[0m \u001b[92m~         std::cmp::Ordering::Equal | std::cmp::Ordering::Greater => todo!()\u001b[0m,\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 1 previous error; 2 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 1 previous error; 2 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"For more information about this error, try `rustc --explain E0004`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about this error, try `rustc --explain E0004`.\u001b[0m\n"}
